<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Some Interesting Things</title>
    <link>http://localhost:1313/</link>
    <description>Recent content in Home on Some Interesting Things</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 Aug 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rice&#39;s Theorem</title>
      <link>http://localhost:1313/rices-theorem/</link>
      <pubDate>Sun, 10 Aug 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/rices-theorem/</guid>
      <description>In my post about diagonalization we proved that the language $A_{TM} := \lbrace \langle M, x \rangle \in A_{TM} | \text{ turing machine } M \text { accepts string } x \rbrace $ is undecidable. But what what else is undecidable? And do we need to use diagonalization to prove it every time? The answers: a lot and no.&#xA;In this post, we&amp;rsquo;ll take a look at a really interesting concept in computer science: Rice&amp;rsquo;s Theorem, which says that any non-trivial property of a language is undecidable.</description>
    </item>
    <item>
      <title>Hacking a Pass Together in LLVM&#39;s OCaml Bindings</title>
      <link>http://localhost:1313/ocaml-llvm-pass/</link>
      <pubDate>Sun, 03 Aug 2025 09:47:53 -0400</pubDate>
      <guid>http://localhost:1313/ocaml-llvm-pass/</guid>
      <description>If you&amp;rsquo;re writing a production quality compiler, it&amp;rsquo;s no longer good enough to just have correct code, you need speed. Compiler optimizations have become an incredibly important aspect of modern compiler design and will only grow in importance as languages are developed for increasingly specialized, computation heavy domains.&#xA;What is LLVM? LLVM (which doesn&amp;rsquo;t stand for anything) is a codegen and optimization engine. It stands out for being architecture independent, so you can write optimizations in LLVM&amp;rsquo;s IR and let LLVM handle generating code for specific architectures.</description>
    </item>
    <item>
      <title>Proof by Diagonalization</title>
      <link>http://localhost:1313/proof-by-diagonalization/</link>
      <pubDate>Thu, 12 Jun 2025 18:46:36 -0400</pubDate>
      <guid>http://localhost:1313/proof-by-diagonalization/</guid>
      <description>If you&amp;rsquo;ve taken a discrete math class, you&amp;rsquo;ve likely covered the common methods of proof: direct, contrapositive, contradiction, and induction. What you may not know is that there&amp;rsquo;s another, less intuitive way of proving something true: proof by diagonalization.&#xA;This post will start with some background, briefly go over the intuition of the diagonalization method, use it prove there is more than one kind of infinity, before concluding with a proof of undecidability.</description>
    </item>
    <item>
      <title>Ogden&#39;s Theorem and Inherent Ambiguity</title>
      <link>http://localhost:1313/ogdens-theorem/</link>
      <pubDate>Fri, 25 Apr 2025 20:23:22 -0400</pubDate>
      <guid>http://localhost:1313/ogdens-theorem/</guid>
      <description>The pumping lemma for context free languages is a useful tool to prove a language to be non context free. But sometimes proofs about CFLs require more powerful tools. William Ogden, during his PhD at Stanford, published a paper that describes a way to generalize a the pumping lemma, allowing you to, in a sense, &amp;ldquo;choose where to pump&amp;rdquo;.&#xA;But why study it? Well, most notably, the theorem lends itself well to a proof about the inherent ambiguity of CFLs; less notably, I think it&amp;rsquo;s cool.</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/all-posts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/all-posts/</guid>
      <description>All Posts Theory Ogdens&amp;rsquo; Theorem Proof By Diagonalization Programming Languages and Compilers Hacking a Pass Together in LLVM&amp;rsquo;s OCaml Bindings </description>
    </item>
  </channel>
</rss>
